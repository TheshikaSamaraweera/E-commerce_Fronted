{"version":3,"file":"react-slice.js","sources":["../src/utils/assignRadioName.ts","../src/createSlice.ts","../src/utils/createStore.ts","../src/utils/debugLogger.ts","../src/utils/useHasChanges.ts"],"sourcesContent":["let index = 0;\nconst radioNames = [\n  'Alpha',\n  'Bravo',\n  'Charlie',\n  'Delta',\n  'Echo',\n  'Foxtrot',\n  'Golf',\n  'Hotel',\n  'India',\n  'Juliett',\n  'Kilo',\n  'Lima',\n  'Mike',\n  'November',\n  'Oscar',\n  'Papa',\n  'Quebec',\n  'Romea',\n  'Sierra',\n  'Tango',\n  'Uniform',\n  'Victor',\n  'Whiskey',\n  'X-ray',\n  'Yankee',\n  'Zulu'\n];\nexport function assignRadioName() {\n  return `State${radioNames[index++ % radioNames.length]}`;\n}\n","import createStore from './utils/createStore';\nimport { ISliceOptions } from './types';\nimport { assignRadioName } from './utils/assignRadioName';\n\n/**\n * createSlice(options)\n * @example\n * createSlice({\n *   reducer: (state, action) => {\n *     if(action === 'increment')Â return state + 1;\n *     if(action === 'decrement')Â return state - 1;\n *     return state;\n *   },\n *   initialState: 0, // optional\n *   debugName: 'Counter' // optional\n * })\n */\n\nexport default function createSlice<TState = any, TActions = any>(\n  options: ISliceOptions<TState, TActions>\n) {\n  if (typeof options !== 'object') {\n    throw Error(\n      'react-slice: createSlice takes options object as first parameter'\n    );\n  }\n\n  if (typeof options.reducer !== 'function') {\n    throw Error('react-slice createSlice must include reducer function');\n  }\n\n  // Make sure we get a nice name (StateAlpha, StateBravo, StateCharlie ðŸ˜‚)\n  if (typeof options.debugName !== 'string') {\n    options.debugName = assignRadioName();\n  }\n\n  return createStore<TState, TActions>(options);\n}\n","import { useState, useEffect } from 'react';\nimport debugLogger from './debugLogger';\nimport useHasChanges from './useHasChanges';\nimport { ISliceOptions, ISliceStore } from '../types';\n\ntype TSubscriptionObject<TState> = {\n  [id: string]: (state: TState) => void;\n};\n\nexport default function createStore<TState, TAction>(\n  options: ISliceOptions<TState, TAction>\n): ISliceStore<TState, TAction> {\n  let state: TState = options.initialState;\n\n  const subscribers: TSubscriptionObject<TState> = {};\n  const notify = (state: TState) => {\n    Object.values(subscribers).forEach((callback) => {\n      callback(state);\n    });\n  };\n  let hasTimer = false;\n  const scheduleUpdate = () => {\n    if (hasTimer) {\n      return;\n    }\n    hasTimer = true;\n    setTimeout(() => {\n      hasTimer = false;\n      notify(state);\n    }, 0);\n  };\n\n  const tempStore: Omit<ISliceStore<TState, TAction>, 'use'> = {\n    subscribe: (callback) => {\n      const id = Math.random().toString(36).substring(7);\n\n      subscribers[id] = callback;\n\n      return () => {\n        delete subscribers[id];\n      };\n    },\n    getState: (): TState => state,\n    dispatch: (action: TAction) => {\n      const prevState = state;\n      state = options.reducer(state, action);\n\n      if (\n        typeof process === 'undefined' ||\n        (process.env.NODE_ENV !== 'production' &&\n          process.env.NODE_ENV !== 'test')\n      ) {\n        debugLogger(options.debugName, action, prevState, state);\n      }\n\n      scheduleUpdate();\n    },\n  };\n\n  const store: ISliceStore<TState, TAction> = {\n    ...tempStore,\n    use: function useSlice(uniqueFn?: (state: TState) => any[]): TState {\n      const [updateBust, setUpdateBust] = useState(new Date());\n      const state: TState = tempStore.getState();\n\n      const hasChanges = useHasChanges<TState>(state, uniqueFn);\n\n      useEffect(() => {\n        return tempStore.subscribe((newState) => {\n          if (hasChanges(newState)) {\n            setUpdateBust(new Date());\n          }\n        });\n      }, [tempStore, hasChanges]);\n\n      return state;\n    },\n  };\n\n  return store;\n}\n","export default <Actions, State>(\n  name: string,\n  action: Actions,\n  prevState: State,\n  nextState: State\n) => {\n  if (typeof console.groupCollapsed !== 'undefined') {\n    const title = [`react-slice`, `%c${name}`];\n    const styles = ['color: gray; font-weight: lighter;', ''];\n\n    console.groupCollapsed(`%c ${title.join(' ')}`, ...styles);\n\n    console.log(\n      '%cprev state   ',\n      'color: #9E9E9E; font-weight: bold;',\n      prevState\n    );\n    console.log('%caction      ', 'color: #03A9F4; font-weight: bold;', action);\n    console.log(\n      '%cnext state   ',\n      'color: #4CAF50; font-weight: bold;',\n      nextState\n    );\n    console.groupEnd();\n  }\n};\n","import { useRef, useCallback, useEffect } from 'react';\n\nexport default function useHasChanges<TState>(\n  slice: TState,\n  updateDepFunc: (state: TState) => any[]\n) {\n  const lastDeps = useRef([]);\n  const hasChanges = useCallback(\n    s => {\n      if (typeof updateDepFunc !== 'function') {\n        return true;\n      }\n\n      const deps = updateDepFunc(s);\n      if (!Array.isArray(deps)) {\n        throw Error(\n          'react-slice: update dependency function returned a non-array'\n        );\n      }\n      let isDifferent = deps.length !== lastDeps.current.length;\n      !isDifferent &&\n        deps.forEach((a, i) => {\n          if (a !== lastDeps.current[i]) {\n            isDifferent = true;\n          }\n        });\n      lastDeps.current = deps;\n      return isDifferent;\n    },\n    [updateDepFunc]\n  );\n\n  useEffect(() => {\n    hasChanges(slice);\n  }, [hasChanges]);\n\n  return hasChanges;\n}\n"],"names":["index","radioNames","options","Error","reducer","debugName","length","state","initialState","subscribers","hasTimer","tempStore","subscribe","callback","id","Math","random","toString","substring","getState","dispatch","action","prevState","process","env","NODE_ENV","name","nextState","console","groupCollapsed","join","log","groupEnd","debugLogger","setTimeout","Object","values","forEach","notify","use","uniqueFn","setUpdateBust","useState","Date","hasChanges","slice","updateDepFunc","lastDeps","useRef","useCallback","s","deps","Array","isArray","isDifferent","current","a","i","useEffect","useHasChanges","newState","createStore"],"mappings":"sOAAA,IAAIA,EAAQ,EACNC,EAAa,CACjB,QACA,QACA,UACA,QACA,OACA,UACA,OACA,QACA,QACA,UACA,OACA,OACA,OACA,WACA,QACA,OACA,SACA,QACA,SACA,QACA,UACA,SACA,UACA,QACA,SACA,qCCRAC,GAEA,GAAuB,iBAAZA,EACT,MAAMC,MACJ,oEAIJ,GAA+B,mBAApBD,EAAQE,QACjB,MAAMD,MAAM,yDAQd,MAJiC,iBAAtBD,EAAQG,YACjBH,EAAQG,kBDHKJ,EAAWD,IAAUC,EAAWK,kBEpB/CJ,GAEA,IAAIK,EAAgBL,EAAQM,aAEtBC,EAA2C,GAM7CC,GAAW,EAYTC,EAAuD,CAC3DC,UAAW,SAACC,GACV,IAAMC,EAAKC,KAAKC,SAASC,SAAS,IAAIC,UAAU,GAIhD,OAFAT,EAAYK,GAAMD,oBAGTJ,EAAYK,KAGvBK,SAAU,kBAAcZ,GACxBa,SAAU,SAACC,GACT,IAAMC,EAAYf,EAClBA,EAAQL,EAAQE,QAAQG,EAAOc,IAGV,oBAAZE,SACmB,eAAzBA,QAAQC,IAAIC,UACc,SAAzBF,QAAQC,IAAIC,oBCjDpBC,EACAL,EACAC,EACAK,cAEsC,IAA3BC,QAAQC,oBAIjBD,SAAQC,8BAHM,oBAAqBH,GAGAI,KAAK,aAFzB,CAAC,qCAAsC,MAItDF,QAAQG,IACN,kBACA,qCACAT,GAEFM,QAAQG,IAAI,iBAAkB,qCAAsCV,GACpEO,QAAQG,IACN,kBACA,qCACAJ,GAEFC,QAAQI,YD6BJC,CAAY/B,EAAQG,UAAWgB,EAAQC,EAAWf,GA9BlDG,IAGJA,GAAW,EACXwB,WAAW,WACTxB,GAAW,EAZA,SAACH,GACd4B,OAAOC,OAAO3B,GAAa4B,QAAQ,SAACxB,GAClCA,EAASN,KAWT+B,CAAO/B,IACN,MAkDL,YAnBKI,GACH4B,IAAK,SAAkBC,OACFC,EAAiBC,WAAS,IAAIC,SAC3CpC,EAAgBI,EAAUQ,WAE1ByB,WE9DVC,EACAC,GAEA,IAAMC,EAAWC,SAAO,IAClBJ,EAAaK,cACjB,SAAAC,GACE,GAA6B,mBAAlBJ,EACT,SAGF,IAAMK,EAAOL,EAAcI,GAC3B,IAAKE,MAAMC,QAAQF,GACjB,MAAMhD,MACJ,gEAGJ,IAAImD,EAAcH,EAAK7C,SAAWyC,EAASQ,QAAQjD,OAQnD,OAPCgD,GACCH,EAAKd,QAAQ,SAACmB,EAAGC,GACXD,IAAMT,EAASQ,QAAQE,KACzBH,GAAc,KAGpBP,EAASQ,QAAUJ,EACZG,GAET,CAACR,IAOH,OAJAY,YAAU,WACRd,EAAWC,IACV,CAACD,IAEGA,EF6BgBe,CAAsBpD,EAAOiC,GAUhD,OARAkB,YAAU,WACR,OAAO/C,EAAUC,UAAU,SAACgD,GACtBhB,EAAWgB,IACbnB,EAAc,IAAIE,SAGrB,CAAChC,EAAWiC,IAERrC,KDvCJsD,CAA8B3D"}